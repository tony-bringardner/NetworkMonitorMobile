import 'package:network_monitor/dns/byte_buffer.dart';
import 'package:network_monitor/dns/utility.dart';
import 'dns.dart';

/// This class represents the Header portion of the DNS record as described in RFC 1035

class Header extends Utility implements DNS {
  static int ref = 0;
  static const int _mask = 0x00FF;

  //  Fields in this order
  static const int _headerLength = 12; //  96 bits , six(6) 16 bit values
  /// 16 bit ID generated by requester *
  int id = 0;

  /// 01 bit == Type of Message (QUERY or RESPONSE) *
  bool qr = false;

  /// 04 bit == Type of Query (QUERY, IQUERY or STATUS) *
  int opcode = DNS.STATUS;

  /// 01 bit == Authoritative answer
  bool aa = false;

  /// 01 bit == Truncated message
  bool tc = false;

  /// 01 bit == Recursion Desired
  bool rd = false;

  /// 01 bit == Recursion Available
  bool ra = false;

  /// 03 bit == Reserved (must be zero )
  int z = 0;

  /// 04 bit == response code
  int rcode = 0;

  /// 16 bit == entries in question
  int qdcount = 0;

  /// 16 bit == RRs in response
  int ancount = 0;

  /// 16 bit == RRs in AUTH(NS) Section
  int nscount = 0;

  /// 16 bit == Additional records
  int arcount = 0;

  /// Default constructor

  Header();

  Header.fromByteBuffer(ByteBuffer inp) {
    init(inp);
  }

  /// Make a copy of this Header with all counts set to zero
  ///
  Header copy() {
    Header ret = Header();

    ret.setID(id);
    ret.setQRFromBool(qr);

    ret.setOPCODE(opcode);
    ret.setAA(aa);
    ret.setTC(tc);
    ret.setRD(rd);
    ret.setRA(ra);
    ret.setRCODE(rcode);

    return ret;
  }

  /// This is always zero.  This function
  /// is just to avaoid the warnings in eclipse
  /// about unused variabls.
  ///
  /// @return
  int getZ() {
    return z;
  }

  /// Get the current value for AA (bool Athoratative Answer) *
  bool getAA() {
    return aa;
  }

  /// Get the number of answer Sections in this Message *
  int getANCOUNT() {
    return ancount;
  }

  int getARCOUNT() {
    return arcount;
  }

  /// Get the ID of the Header *
  int getID() {
    return id;
  }

  /** Get the number of NS (Name Server) sections in this Message **/
  /// Get the Message Type of this Message (QUERY or RESPONSE) *
  bool getMessageType() {
    return qr;
  }

  int getNSCOUNT() {
    return nscount;
  }

  /// Get the OPCODE of this Message (QUERY, IQUERY or STATUS) *
  int getOPCODE() {
    return opcode;
  }

  /// Get the number of Question Sections in this Message *
  int getQDCOUNT() {
    return qdcount;
  }
  /** Same as getOPCODE **/
  /// Get the current value of QR (same as getMessageType) *

  bool getQR() {
    return qr;
  }

  int getQueryType() {
    return opcode;
  }

  /// Get the current value of RCODE (Response Code) **/
  /// Get the current value of RA (Recursion Available) **/
  bool getRA() {
    return ra;
  }

  int getRCODE() {
    return rcode;
  }

  /// Set the value for ID (Id for this Message) **/
  /// Get the current value of RD (Recursion Desired) **/
  bool getRD() {
    return rd;
  }


  ///    Create a new reference number suitable for use in the Header.id field
  ///    This could be synced but I don't see a problem if it's not

  static int getRef() {
    return ++ref;
  }

  /// Get the current value of TC (Truncated Message, 512 limit for UDP) *
  bool getTC() {
    return tc;
  }

  /// Construct a header from a ByteBuffer\

  void init(ByteBuffer inPut) {
    id = inPut.nextShort();
    int tmp = inPut.nextShort();

    qr = isSet(tmp, 15);
    opcode = (tmp >> 11) & 0xf;
    aa = isSet(tmp, 10);
    tc = isSet(tmp, 9);
    rd = isSet(tmp, 8);
    ra = isSet(tmp, 7);
    z = 0; // bits 6,5,4
    rcode = (tmp & 0x0f); //  bits 3,2,1,0
    qdcount = inPut.nextShort();
    ancount = inPut.nextShort();
    nscount = inPut.nextShort();
    arcount = inPut.nextShort();
  }

  /// Set the value for AA (Authoratative Answer) *
  void setAA(bool authOrNot) {
    aa = authOrNot;
  }

  /// Set the value for ANCOUNT (Number of records in the answer section) *
  void setANCOUNT(int ansCount) {
    ancount = ansCount;
  }


  ///    Set the value for ARCOUNT (Number of additional records,
  ///    normally addresses for records that appear in other sections)

  void setARCOUNT(int additionalCount) {
    arcount = additionalCount;
  }

  void setID(int idGenByRequestor) {
    id = idGenByRequestor;
  }

  /// Set the value for Message Type (QR) (Query or Response) *
  void setMessageType(int qr) {
    setQR(qr);
  }

  /// Set the value for OPCODE ( Type of Query {QUERY, IQUERY or STATUS} )
  /// Set the value for NSCOUNT (Number of Name Server records in the NS section)
  ///
  void setNSCOUNT(int b) {
    nscount = b;
  }

  void setOPCODE(int cd) {
    opcode = cd;
  }

  /** Set the value for QR (same as setMessageType) **/
  /// Set the value for QDCOUNT (Number of records in the Question section) *
  void setQDCOUNT(int b) {
    qdcount = b;
  }

  void setQR(int t) {
    if (t == DNS.QUERY) {
      qr = false;
    } else if (t == DNS.RESPONSE) {
      qr = true;
    } else {
      //   Not a valid value
      throw Exception("Invalid QTYPE $t");
    }
  }

  /// Set the value for QR (same as setMessageType)
  /// true == QUERY , false = RESPONSE
  ///
  void setQRFromBool(bool qORnot) {
    qr = qORnot;
  }

  void setQueryType(int newOpcode) {
    opcode = newOpcode;
  }

  /** Set the value for RCODE (Response Code) **/
  /// Set the value for RA (Recursion Available) *
  void setRA(bool b) {
    ra = b;
  }

  void setRCODE(int cd) {
    rcode = cd;
  }

  /**
   * Write this header into a ByteBuffer
   **/
  /// Set the value for RD (Recursion Desired) *
  void setRD(bool b) {
    rd = b;
  }

  /// Set the value for Reference (Used in getRef) *
  static void setRef(int s) {
    ref = s;
  }

  /// Set the value for TC (Truncated) *
  void setTC(bool b) {
    tc = b;
  }


  ///    Size of the Header

  int size() {
    return _headerLength;
  }

  /// Return a byte arry representation of this header

  List<int> toByteArray() {
    ByteBuffer b = ByteBuffer.fromNew();

    toByteArray2(b);

    return b.getInternalBufffer();
  }

  /// Write this header into a ByteBuffer

  void toByteArray2(ByteBuffer buf) {
    // Set bytes 0, 1 from id
    buf.setShort(id);

    //  Build a int from flags
    int tmp = 0;
    if (qr) {
      tmp = Utility.setBit(tmp, 15);
    }
    //  Set bits 14,13,12,11 from opcode
    tmp = (tmp | ((opcode & _mask) << 11));

    if (aa) {
      tmp = Utility.setBit(tmp, 10);
    }
    if (tc) {
      tmp = Utility.setBit(tmp, 9);
    }
    if (rd) {
      tmp = Utility.setBit(tmp, 8);
    }
    if (ra) {
      tmp = Utility.setBit(tmp, 7);
    }

    // z == 0 nothing to do for bits 6,5,4

    //  Set bits 3,2,1,0 from rcode
    tmp = (tmp | (rcode & _mask));

    // Set bytes 2,3 from this 16 bit value
    buf.setShort(tmp);
    buf.setShort(qdcount);
    buf.setShort(ancount);
    buf.setShort(nscount);
    buf.setShort(arcount);
  }

  @override
  String toString() {
    String ret = "";

    // Set bytes 0, 1 from id
    ret += "id=$id";
    ret +=
        "\n qr=${qr ? DNS.QUERYNAMES[1] : DNS.QUERYNAMES[0]} /** 01 bit == Type of Message (QUERY or RESPONSE) **/";
    ret += "\n opcode=$opcode";
    ret +=
        " (${DNS.OPCODENAMES[opcode & 0xff]} 04 bit == Type of Query (QUERY, IQUERY or STATUS)";
    ret += "\n aa=$aa tc=$tc  rd=$rd  ra=$ra";

    // z == 0 nothing to do for bits 6,5,4

    //  Set bits 3,2,1,0 from rcode
    ret += "\n rcode=$rcode (${DNS.ERRORNAMES[rcode]})";

    // Set bytes 2,3 from this 16 bit value
    ret += "\n qdcount=$qdcount";
    ret += " ancount=$ancount";
    ret += " nscount=$nscount";
    ret += " arcount=$arcount";

    return ret.toString();
  }
}
